<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>六、Git版本控制工具的深入学习 | Lyk-Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/common/favicon.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.staticfile.org/jquery/1.7.2/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/BaiduStatistics.js"></script>
    <meta name="description" content="前端技术入口 →">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.68026456.css" as="style"><link rel="preload" href="/assets/js/app.d92951ef.js" as="script"><link rel="preload" href="/assets/js/3.ad8ffd82.js" as="script"><link rel="preload" href="/assets/js/1.7d84b754.js" as="script"><link rel="preload" href="/assets/js/29.d124476c.js" as="script"><link rel="prefetch" href="/assets/js/10.7798ee85.js"><link rel="prefetch" href="/assets/js/11.534c9110.js"><link rel="prefetch" href="/assets/js/12.950d3e66.js"><link rel="prefetch" href="/assets/js/13.a6c06a2f.js"><link rel="prefetch" href="/assets/js/14.f6c22294.js"><link rel="prefetch" href="/assets/js/15.ba551ac9.js"><link rel="prefetch" href="/assets/js/16.ef3fee9f.js"><link rel="prefetch" href="/assets/js/17.32bff755.js"><link rel="prefetch" href="/assets/js/18.5975127a.js"><link rel="prefetch" href="/assets/js/19.e2a786ea.js"><link rel="prefetch" href="/assets/js/20.5bf800fc.js"><link rel="prefetch" href="/assets/js/21.0b07e50a.js"><link rel="prefetch" href="/assets/js/22.77239734.js"><link rel="prefetch" href="/assets/js/23.335d3933.js"><link rel="prefetch" href="/assets/js/24.de408af0.js"><link rel="prefetch" href="/assets/js/25.dff0ffab.js"><link rel="prefetch" href="/assets/js/26.e219ffa8.js"><link rel="prefetch" href="/assets/js/27.2ece2bf4.js"><link rel="prefetch" href="/assets/js/28.dbcff045.js"><link rel="prefetch" href="/assets/js/30.45c5c020.js"><link rel="prefetch" href="/assets/js/31.e8100af5.js"><link rel="prefetch" href="/assets/js/32.cfdec1e1.js"><link rel="prefetch" href="/assets/js/33.834a8767.js"><link rel="prefetch" href="/assets/js/34.8842d9a1.js"><link rel="prefetch" href="/assets/js/35.14eebe80.js"><link rel="prefetch" href="/assets/js/36.faedcc67.js"><link rel="prefetch" href="/assets/js/37.f3d6adab.js"><link rel="prefetch" href="/assets/js/38.6fd7f2f6.js"><link rel="prefetch" href="/assets/js/39.4a60fc66.js"><link rel="prefetch" href="/assets/js/4.8a2c5ad1.js"><link rel="prefetch" href="/assets/js/40.c2679092.js"><link rel="prefetch" href="/assets/js/41.072dd044.js"><link rel="prefetch" href="/assets/js/42.a73141ce.js"><link rel="prefetch" href="/assets/js/43.92fde6da.js"><link rel="prefetch" href="/assets/js/44.968192e8.js"><link rel="prefetch" href="/assets/js/45.eb30ae23.js"><link rel="prefetch" href="/assets/js/46.ecba5621.js"><link rel="prefetch" href="/assets/js/47.ba2a414b.js"><link rel="prefetch" href="/assets/js/48.27158afc.js"><link rel="prefetch" href="/assets/js/49.48a6ee96.js"><link rel="prefetch" href="/assets/js/5.700aedd1.js"><link rel="prefetch" href="/assets/js/50.b409fb96.js"><link rel="prefetch" href="/assets/js/51.6bbf4f8d.js"><link rel="prefetch" href="/assets/js/52.9357e8d7.js"><link rel="prefetch" href="/assets/js/53.b08b343e.js"><link rel="prefetch" href="/assets/js/54.b629e4ee.js"><link rel="prefetch" href="/assets/js/55.edbd9557.js"><link rel="prefetch" href="/assets/js/56.9bb326a4.js"><link rel="prefetch" href="/assets/js/57.4fa33063.js"><link rel="prefetch" href="/assets/js/58.b6d28074.js"><link rel="prefetch" href="/assets/js/59.0e7e4fc5.js"><link rel="prefetch" href="/assets/js/6.fe5ccade.js"><link rel="prefetch" href="/assets/js/60.326032e9.js"><link rel="prefetch" href="/assets/js/61.1264c243.js"><link rel="prefetch" href="/assets/js/62.ec93ae7f.js"><link rel="prefetch" href="/assets/js/63.932457f3.js"><link rel="prefetch" href="/assets/js/64.3bac4365.js"><link rel="prefetch" href="/assets/js/65.bfde7ed1.js"><link rel="prefetch" href="/assets/js/66.8bdf7d7b.js"><link rel="prefetch" href="/assets/js/67.b60d74bc.js"><link rel="prefetch" href="/assets/js/68.3bfacf6d.js"><link rel="prefetch" href="/assets/js/69.1720cd68.js"><link rel="prefetch" href="/assets/js/7.521988a7.js"><link rel="prefetch" href="/assets/js/70.08a565ce.js"><link rel="prefetch" href="/assets/js/71.ed4fbb13.js"><link rel="prefetch" href="/assets/js/72.4b37c5fc.js"><link rel="prefetch" href="/assets/js/73.bd29e870.js"><link rel="prefetch" href="/assets/js/74.e2540619.js"><link rel="prefetch" href="/assets/js/75.79c65819.js"><link rel="prefetch" href="/assets/js/76.0298876a.js"><link rel="prefetch" href="/assets/js/77.bd142136.js"><link rel="prefetch" href="/assets/js/78.3fa951a0.js"><link rel="prefetch" href="/assets/js/79.11c9f441.js"><link rel="prefetch" href="/assets/js/8.5472d0c3.js"><link rel="prefetch" href="/assets/js/80.ff9c909f.js"><link rel="prefetch" href="/assets/js/81.47f29a82.js"><link rel="prefetch" href="/assets/js/82.0ac22b00.js"><link rel="prefetch" href="/assets/js/83.60818c64.js"><link rel="prefetch" href="/assets/js/84.643e4a77.js"><link rel="prefetch" href="/assets/js/85.7054441e.js"><link rel="prefetch" href="/assets/js/86.4b8fa46d.js"><link rel="prefetch" href="/assets/js/9.be766b03.js">
    <link rel="stylesheet" href="/assets/css/0.styles.68026456.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Lyk-Blog</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>前端技术入口 →</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Lyk</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/common/logo.jpg" alt="Lyk-Blog" class="logo"> <span class="site-name">Lyk-Blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/ES6/" class="nav-link"><i class="undefined"></i>
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端工程化/" class="nav-link"><i class="undefined"></i>
  前端工程化
</a></li><li class="dropdown-item"><!----> <a href="/categories/HTML+CSS/" class="nav-link"><i class="undefined"></i>
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript高级/" class="nav-link"><i class="undefined"></i>
  JavaScript高级
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript基础/" class="nav-link"><i class="undefined"></i>
  JavaScript基础
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vuejs/" class="nav-link"><i class="undefined"></i>
  Vuejs
</a></li><li class="dropdown-item"><!----> <a href="/categories/TypeScript/" class="nav-link"><i class="undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/微信小程序/" class="nav-link"><i class="undefined"></i>
  微信小程序
</a></li><li class="dropdown-item"><!----> <a href="/categories/博客/" class="nav-link"><i class="undefined"></i>
  博客
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      文章目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/frontEnd/" class="nav-link router-link-active"><i class="undefined"></i>
  前端技术
</a></li><li class="dropdown-item"><!----> <a href="/docs/" class="nav-link"><i class="undefined"></i>
  博客搭建
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系lyk
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyk19990226" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_43528628?type=blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/img/common/avatar.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    Lyk
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>73</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>490</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/ES6/" class="nav-link"><i class="undefined"></i>
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端工程化/" class="nav-link"><i class="undefined"></i>
  前端工程化
</a></li><li class="dropdown-item"><!----> <a href="/categories/HTML+CSS/" class="nav-link"><i class="undefined"></i>
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript高级/" class="nav-link"><i class="undefined"></i>
  JavaScript高级
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript基础/" class="nav-link"><i class="undefined"></i>
  JavaScript基础
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vuejs/" class="nav-link"><i class="undefined"></i>
  Vuejs
</a></li><li class="dropdown-item"><!----> <a href="/categories/TypeScript/" class="nav-link"><i class="undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/微信小程序/" class="nav-link"><i class="undefined"></i>
  微信小程序
</a></li><li class="dropdown-item"><!----> <a href="/categories/博客/" class="nav-link"><i class="undefined"></i>
  博客
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      文章目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/frontEnd/" class="nav-link router-link-active"><i class="undefined"></i>
  前端技术
</a></li><li class="dropdown-item"><!----> <a href="/docs/" class="nav-link"><i class="undefined"></i>
  博客搭建
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系lyk
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyk19990226" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_43528628?type=blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/blogs/frontEnd/" aria-current="page" class="sidebar-link">前端技术学习目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端学习网站和软件下载</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML+CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript高级</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ECMAScript6~13</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端工程化基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/frontEnd/Engineering/220814-01.html" class="sidebar-link">一、初识Nodejs开发</a></li><li><a href="/blogs/frontEnd/Engineering/220815-01.html" class="sidebar-link">二、Javascript的模块化开发【CommonJS和ESModule模块化开发】</a></li><li><a href="/blogs/frontEnd/Engineering/220816-01.html" class="sidebar-link">三、前端开发常用的包管理工具(npm,yarn,pnpm,cnpm,npx)深入学习</a></li><li><a href="/blogs/frontEnd/Engineering/220817-01.html" class="sidebar-link">四、邂逅webpack 和 静态模块化打包文件及相关配置的深入学习</a></li><li><a href="/blogs/frontEnd/Engineering/220818-01.html" class="sidebar-link">五、webpack常见的插件和模式 及 webpack搭建本地服务器</a></li><li><a href="/blogs/frontEnd/Engineering/220819-01.html" aria-current="page" class="active sidebar-link">六、Git版本控制工具的深入学习</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue3.0</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微信小程序</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>六、Git版本控制工具的深入学习</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Lyk</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">六、Git版本控制工具的深入学习</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>Lyk</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2022/8/19</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>前端工程化</span><span class="tag-item" data-v-1ff7123e>Git</span></i></div></div> <div class="theme-reco-content content__default"><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener noreferrer">git官网命令查询<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_1、版本控制工具的了解"><a href="#_1、版本控制工具的了解" class="header-anchor">#</a> 1、版本控制工具的了解</h2> <h3 id="_1-1-认识版本控制-版本控制"><a href="#_1-1-认识版本控制-版本控制" class="header-anchor">#</a> 1.1.认识版本控制（版本控制）</h3> <ul><li>什么是版本控制？</li> <li>版本控制的英文是Version control；</li> <li>是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程；</li> <li>版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步；</li> <li>简单来说，版本控制在软件开发中，可以帮助程序员进行代码的追踪、维护、控制等等一系列的操作。</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/20/11b79c221fc09e034.png" alt="11b79c221fc09e034.png"></p> <h3 id="_1-2-版本控制的功能"><a href="#_1-2-版本控制的功能" class="header-anchor">#</a> 1.2.版本控制的功能</h3> <ul><li>对于我们日常开发，我们常常面临如下一些问题，通过版本控制可以很好的解决：</li> <li>不同版本的存储管理：
<ul><li>一个项目会不断进行版本的迭代，来修复之前的一些问题、增加新的功能、需求，甚至包括项目的重构；</li> <li>如果我们通过手动来维护一系列的项目备份，简直是一场噩梦；</li></ul></li> <li>重大版本的备份维护：
<ul><li>对于很多重大的版本，我们会进行备份管理；</li></ul></li> <li>恢复之前的项目版本：
<ul><li>当我们开发过程中发生一些严重的问题时，想要恢复之前的操作或者回到之前某个版本；</li></ul></li> <li>记录项目的点点滴滴：
<ul><li>如果我们每一个功能的修改、bug的修复、新的需求更改都需要记录下来，版本控制可以很好的解决；</li></ul></li> <li>多人开发的代码合并：
<ul><li>项目中通常都是多人开发，将多人代码进行合并，并且在出现冲突时更好的进行处理；</li></ul></li></ul> <h3 id="_1-3-版本控制的历史"><a href="#_1-3-版本控制的历史" class="header-anchor">#</a> 1.3.版本控制的历史</h3> <ul><li>版本控制的史前时代（没有版本控制）：</li> <li>人们通常通过文件备份的方式来进行管理，再通过diff命令来对比两个文件的差异；</li> <li><strong>CVS</strong>（Concurrent Versions System）</li> <li>第一个被大规模使用的版本控制工具，诞生于1985年；</li> <li>由荷兰阿姆斯特丹VU大学的Dick Grune教授实现的，也算是SVN的前身（SVN的出现就是为了取代CVS的）。</li> <li><strong>SVN</strong>（Subversion）</li> <li>因其命令行工具名为svn因此通常被简称为SVN；</li> <li>SVN由CollabNet公司于2000年资助并发起开发，目的是取代CVS，对CVS进行了很多的优化；</li> <li>SVN和CVS一样，也属于集中式版本控制工具；</li> <li>SVN在早期公司开发中使用率非常高，但是目前已经被Git取代；</li> <li><strong>Git</strong>（Linus的作品）</li> <li>早期的时候，Linux社区使用的是<strong>BitKeeper</strong>来进行版本控制；</li> <li>但是因为一些原因，BitKeeper想要收回对Linux社区的免费授权；</li> <li>于是Linus用了大概一周的时间，开发了Git用来取代BitKeeper；</li> <li>Linus完成了Git的核心设计，在之后Linus功成身退，将Git交由另外一个Git的主要贡献者Junio C Hamano来维护；</li></ul> <h2 id="_2、集中式和分布式区别"><a href="#_2、集中式和分布式区别" class="header-anchor">#</a> 2、集中式和分布式区别</h2> <h3 id="_2-1-集中式版本控制"><a href="#_2-1-集中式版本控制" class="header-anchor">#</a> 2.1.集中式版本控制</h3> <ul><li>CVS和SVN都是是属于集中式版本控制系统（Centralized Version Control Systems，简称 CVCS）
<ul><li>它们的主要特点是单一的集中管理的服务器，保存所有文件的修订版本；</li> <li>协同开发人员通过客户端连接到这台服务器，取出最新的文件或者提交更新；</li></ul></li> <li>这种做法带来了许多好处，特别是相较于老式的本地管理来说，每个人都可以在一定程度上看到项目中的其他人正在做些什么。</li> <li>但是集中式版本控制也有一个核心的问题：中央服务器不能出现故障：
<ul><li>如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作；</li> <li>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/20/2167f29452fdb7b13.png" alt="2167f29452fdb7b13.png"></p> <h3 id="_2-2-分布式版本控制"><a href="#_2-2-分布式版本控制" class="header-anchor">#</a> 2.2.分布式版本控制</h3> <ul><li>Git是属于分布式版本控制系统（Distributed Version Control System，简称 DVCS）
<ul><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录；</li> <li>这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复；</li> <li>因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份；</li></ul></li> <li>目前在公司开发中我们都是使用Git来管理项目的，所以接下来我们会重点学习Git的各种用法；</li></ul> <h2 id="_3、git的环境安装搭建"><a href="#_3、git的环境安装搭建" class="header-anchor">#</a> 3、Git的环境安装搭建</h2> <h3 id="_3-1-git的安装"><a href="#_3-1-git的安装" class="header-anchor">#</a> 3.1.Git的安装</h3> <ul><li>电脑上要想使用Git，我们需要先对Git进行安装：
<ul><li>Git的官网：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">git官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>根据自己的操作系统下载Git即可；</li></ul></li> <li>在window操作系统按照默认配置全局安装即可；</li></ul> <h3 id="_3-2-bash-cmd-gui-区别"><a href="#_3-2-bash-cmd-gui-区别" class="header-anchor">#</a> 3.2.Bash – CMD – GUI 区别</h3> <ul><li>Bash，Unix shell 的一种，Linux 与 Mac OS X 都将它作为默认 shell。
<ul><li>Git Bash 就是一个 shell，是 Windows 下的命令行工具，可以执行 Linux 命令；</li> <li>Git Bash 是基于 CMD 的，在 CMD 的基础上增添一些新的命令与功能；</li> <li>所以建议在使用的时候，用 Bash 更加方便；</li></ul></li> <li>Git CMD
<ul><li>命令行提示符（CMD）是 Windows 操作系统上的命令行解释程序；</li> <li>当你在 Windows 上安装 git 并且习惯使用命令行时，可以使用 cmd 来运行 git 命令；</li></ul></li> <li>Git GUI
<ul><li>基本上针对那些不喜欢黑屏（即命令行）编码的人；</li> <li>它提供了一个图形用户界面来运行 git 命令；</li></ul></li></ul> <h3 id="_3-3-git的配置分类"><a href="#_3-3-git的配置分类" class="header-anchor">#</a> 3.3.Git的配置分类</h3> <ul><li>既然已经在系统上安装了 Git，你会需要做几件事来定制你的 Git 环境：
<ul><li>每台计算机上只需要配置一次，程序升级时会保留配置信息；</li> <li>你可以在任何时候再次通过运行命令来修改它们；</li></ul></li> <li>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量：
<ul><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置
<ul><li>如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量；</li> <li>由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。（开发中通常不修改）</li></ul></li> <li>~/.gitconfig 或 C/users/Lyka/.gitconfig 文件：只针对当前用户
<ul><li>你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有的仓库生效；</li></ul></li> <li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库
<ul><li>你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它；</li></ul></li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/20/46b504475a7dd0e2f.png" alt="46b504475a7dd0e2f.png"></p> <h3 id="_3-4-git的配置选项"><a href="#_3-4-git的配置选项" class="header-anchor">#</a> 3.4.Git的配置选项</h3> <ul><li>安装Git后，要做的第一件事就是设置你的用户名和邮件地址。
<ul><li>这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改；</li> <li>如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">&quot;lyka&quot;</span>
<span class="token function">git</span> confit --global user.email <span class="token string">&quot;1272198474@qq.com&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>检测当前的配置信息：git config --list</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/20/5e942b651b243e00d.png" alt="5e942b651b243e00d.png"></p> <h3 id="_3-5-git的别名-alias"><a href="#_3-5-git的别名-alias" class="header-anchor">#</a> 3.5.Git的别名（alias）</h3> <ul><li>Git 并不会在你输入部分命令时自动推断出你想要的命令：
<ul><li>如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/20/64c027ff4d6b59282.png" alt="64c027ff4d6b59282.png"></p> <h2 id="_4、git初始化本地仓库"><a href="#_4、git初始化本地仓库" class="header-anchor">#</a> 4、Git初始化本地仓库</h2> <h3 id="_4-1-获取git仓库-git-init-git-clone"><a href="#_4-1-获取git仓库-git-init-git-clone" class="header-anchor">#</a> 4.1.获取Git仓库 – git init/git clone</h3> <ul><li><p>我们需要一个Git来管理源代码，那么我们本地也需要有一个Git仓库。</p></li> <li><p>通常有两种获取 Git 项目仓库的方式：</p> <ul><li>方式一：初始化一个Git仓库，并且可以将当前项目的文件都添加到Git仓库中（目前很多的脚手架在创建项目时都会默认创建一个Git仓库）；</li> <li>方式二：从其它服务器 克隆（clone） 一个已存在的 Git 仓库（第一天到公司通常我们需要做这个操作）；</li></ul></li> <li><p>方式一：初始化Git仓库</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> init
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的核心；</li> <li>但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪；</li></ul></li> <li><p>方式二：从Git远程仓库</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/lyk19990226/WebpackFoundation.git
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h2 id="_5、git记录更新变化过程"><a href="#_5、git记录更新变化过程" class="header-anchor">#</a> 5、Git记录更新变化过程</h2> <h3 id="_5-1-文件的状态划分"><a href="#_5-1-文件的状态划分" class="header-anchor">#</a> 5.1.文件的状态划分</h3> <ul><li>现在我们的电脑上已经有一个Git仓库：
<ul><li>在实际开发中，你需要将某些文件交由这个Git仓库来管理；</li> <li>并且我们之后会修改文件的内容，当达成某一个目标时，想要记录下来这次操作，就会将它提交到仓库中；</li></ul></li> <li>那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理：
<ul><li>未跟踪(Untracked)：默认情况下，Git仓库下的文件没有添加到Git仓库管理中，我们需要通过add命令来操作；</li> <li>已跟踪：添加到Git仓库管理的文件处于已跟踪状态，Git可以对其进行各种跟踪管理；</li></ul></li> <li>已跟踪的文件又可以进行细分状态划分：
<ul><li>staged：暂缓区中的文件状态；</li> <li>Unmodified(未更改的)：commit命令，可以将staged中文件提交到本地Git仓库</li> <li>Modified(稍作修改了)：修改了某个文件后，会处于Modified状态；</li></ul></li> <li>在工作时，你可以选择性地将这些修改过的文件放入暂存区；</li> <li>然后提交所有已暂存的修改，如此反复；</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/748a4a313aaa0d758.png" alt="748a4a313aaa0d758.png"></p> <h3 id="_5-2-git操作流程图"><a href="#_5-2-git操作流程图" class="header-anchor">#</a> 5.2.Git操作流程图</h3> <p><img src="https://s1.imagehub.cc/images/2022/08/21/87b8534a79e035d42.png" alt="87b8534a79e035d42.png"></p> <h3 id="_5-3-检测文件的状态-git-status"><a href="#_5-3-检测文件的状态-git-status" class="header-anchor">#</a> 5.3.检测文件的状态 - git status</h3> <ul><li>我们在有Git仓库的目录下新建一个文件，查看文件的状态：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> status
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>Untracked files：未跟踪的文件
<ul><li>未跟踪的文件意味着 Git 在之前的提交中没有这些文件；</li> <li>Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”；</li></ul></li> <li>我们也可以查看更加简洁的状态信息：
<ul><li>左栏指明了暂存区的状态，右栏指明了工作区的状态；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> status -s
<span class="token function">git</span> status -short
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/9f478dfaea8b9e996.png" alt="9f478dfaea8b9e996.png"></p> <h3 id="_5-4-文件添加到暂存区-git-add"><a href="#_5-4-文件添加到暂存区-git-add" class="header-anchor">#</a> 5.4.文件添加到暂存区 – git add</h3> <ul><li>跟踪新文件命令：(跟踪具体文件)
<ul><li>使用命令 git add 开始跟踪一个文件。</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> aaa.js
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>跟踪修改的文件命令：
<ul><li>如果我们已经跟踪了某一个文件，这个时候修改了文件也需要重新添加到暂存区中；</li></ul></li> <li>通过git add . 将所有的文件添加到暂存区中：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_5-5-git忽略文件-gitignore文件"><a href="#_5-5-git忽略文件-gitignore文件" class="header-anchor">#</a> 5.5.git忽略文件（.gitignore文件）</h3> <ul><li>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。
<ul><li>通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等；</li> <li>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式；</li></ul></li> <li>在实际开发中，这个文件通常不需要手动创建，在必须的时候添加自己的忽略内容即可；
<ul><li>当然github上也有小伙伴整理了.gitignore模板的集合：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">.gitignore模板集合<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li>如下图是创建的Vue项目自动创建的忽略文件：
<ul><li>包括一些不需要提交的文件、文件夹；</li> <li>包括本地环境变量文件；</li> <li>包括一些日志文件；</li> <li>包括一些编辑器自动生成的文件；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/10bd76e7653401fbe4.png" alt="10bd76e7653401fbe4.png"></p> <h3 id="_5-6-文件更新提交-git-commit-m"><a href="#_5-6-文件更新提交-git-commit-m" class="header-anchor">#</a> 5.6.文件更新提交 – git commit -m</h3> <ul><li>现在的暂存区已经准备就绪，可以提交了。
<ul><li>每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了；</li> <li>再运行提交命令 git commit；</li> <li>可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行;</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> commit –m <span class="token string">&quot;提交信息&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>如果我们修改文件的add操作，加上commit的操作有点繁琐，那么可以将两个命令结合来使用：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> commit -a -m <span class="token string">&quot;修改了xxx.js文件&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_5-7-git的校验和"><a href="#_5-7-git的校验和" class="header-anchor">#</a> 5.7.Git的校验和</h3> <ul><li>Git 中所有的数据在存储前都计算校验和，然后以 校验和 来引用。
<ul><li>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；</li> <li>这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/11f6dbce8975dfecc4.png" alt="11f6dbce8975dfecc4.png"></p> <h3 id="_5-8-查看提交的历史-git-log"><a href="#_5-8-查看提交的历史-git-log" class="header-anchor">#</a> 5.8.查看提交的历史 – git log</h3> <ul><li>在提交了若干更新，又或者克隆了某个项目之后，有时候我们想要查看一下所有的历史提交记录。</li> <li>这个时候我们可以使用git log命令：
<ul><li>不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面；</li> <li>这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> log  // 历史提交记录
<span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline //漂亮单线历史提交记录
<span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline --graph //漂亮的图形单线历史提交记录
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/12ca3d2a7b2a8e0d3f.png" alt="12ca3d2a7b2a8e0d3f.png"></p> <h3 id="_5-9-版本回退-git-reset"><a href="#_5-9-版本回退-git-reset" class="header-anchor">#</a> 5.9.版本回退 – git reset</h3> <ul><li>如果想要进行版本回退，我们需要先知道目前处于哪一个版本：Git通过HEAD指针记录当前版本。</li> <li>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交；</li> <li>理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照；</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/13e42b6f094cffd844.png" alt="13e42b6f094cffd844.png"></p> <ul><li>我们可以通过HEAD来改变Git目前的版本指向：
<ul><li>上一个版本就是HEAD^，上上一个版本就是HEAD^^；</li> <li>如果是上1000个版本，我们可以使用HEAD~1000；</li> <li>我们可以可以指定某一个commit id；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset --hard HEAD^ //回退到上一个版本，上上一个版本就是HEAD^^
<span class="token function">git</span> reset --hard HEAD~1000 //回退到上1000个版本
<span class="token function">git</span> reset --hard 2d44982 //回退到具体版本（指定具体版本的校验和）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_6、git远程仓库和验证"><a href="#_6、git远程仓库和验证" class="header-anchor">#</a> 6、Git远程仓库和验证</h2> <h3 id="_6-1-什么是远程仓库"><a href="#_6-1-什么是远程仓库" class="header-anchor">#</a> 6.1.什么是远程仓库？</h3> <ul><li>什么是远程仓库（Remote Repository）呢？
<ul><li>目前我们的代码是保存在一个本地仓库中，也就意味着我们只是在进行本地操作；</li> <li>在真实开发中，我们通常是多人开发的，所以我们会将管理的代码共享到远程仓库中；</li></ul></li> <li>那么如何创建一个远程仓库呢？
<ul><li>远程仓库通常是搭建在某一个服务器上的（当然本地也可以，但是本地很难共享）；</li> <li>所以我们需要在Git服务器上搭建一个远程仓库；</li></ul></li> <li>目前我们有如下方式可以使用Git服务器：
<ul><li>使用第三方的Git服务器：比如GitHub、Gitee、Gitlab等等；</li> <li>在自己服务器搭建一个Git服务；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/143bd6dfa7014d571f.png" alt="143bd6dfa7014d571f.png"></p> <h3 id="_6-2-远程仓库的验证"><a href="#_6-2-远程仓库的验证" class="header-anchor">#</a> 6.2.远程仓库的验证</h3> <ul><li>常见的远程仓库有哪些呢？目前比较流行使用的是三种：
<ul><li>GitHub：https://github.com/</li> <li>Gitee：https://gitee.com/</li> <li>codewhy搭建Gitlab：http://152.136.185.210:7888/ （由于gitlab服务器在国外；所以很大概率访问不到，需要通过科学上网方式访问；一般公司会搭建自己的gitlab;具体如何搭建，可以网上搜搜哦；这里不做解释）</li></ul></li> <li>对于私有的仓库我们想要进行操作，远程仓库会对我们的身份进行验证：
<ul><li>如果没有验证，任何人都可以随意操作仓库是一件非常危险的事情；</li></ul></li> <li>目前Git服务器验证手段主要有两种：
<ul><li>方式一：<strong>基于HTTP的凭证存储</strong>（Credential Storage）；</li> <li>方式二：<strong>基于SSH的密钥；</strong></li></ul></li> <li>下面我们来具体讨论一下这两种方式的验证规则和过程；</li></ul> <h3 id="_6-3-远程仓库的验证-凭证"><a href="#_6-3-远程仓库的验证-凭证" class="header-anchor">#</a> 6.3.远程仓库的验证 – 凭证</h3> <ul><li>因为本身HTTP协议是<strong>无状态</strong>的连接，所以每一个连接都需要用户名和密码：
<ul><li>如果每次都这样操作，那么会非常麻烦；</li> <li>幸运的是，Git 拥有一个凭证系统来处理这个事情； <a href="https://aka.ms/gcmcore" target="_blank" rel="noopener noreferrer">Git Credential Manager Core (GCM Core)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>GCM 包含在<a href="https://gitforwindows.org/" target="_blank" rel="noopener noreferrer">Git for Windows<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，并且最新版本包含在每个新的 Git for Windows 版本中。这是在 Windows 上安装 GCM 的首选方式。在安装过程中，您将被要求选择一个凭证助手，并将 GCM 设置为默认值。</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/168baec6f0b3864214.png" alt="168baec6f0b3864214.png"></p> <ul><li>下面有一些 Git Crediential 的选项：（之前的方案-&gt;了解）
<ul><li>选项一：默认所有都不缓存。 每一次连接都会询问你的用户名和密码；</li> <li>选项二：“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除；</li> <li>选项三：“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期；</li> <li>选项四：如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中（加密的）；</li> <li>选项五：如果你使用的是 Windows，你可以安装一个叫做 “Git Credential Manager for Windows” 的辅助工具；
<ul><li>可以在 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" target="_blank" rel="noopener noreferrer">Git-Credential-Manager-for-Windows<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 下载。</li></ul></li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/17fc07ef269051c312.png" alt="17fc07ef269051c312.png"></p> <h3 id="_6-4-远程仓库的验证-ssh密钥"><a href="#_6-4-远程仓库的验证-ssh密钥" class="header-anchor">#</a> 6.4.远程仓库的验证 – SSH密钥</h3> <ul><li>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。</li> <li>SSH以非对称加密实现身份验证。
<ul><li>例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；</li> <li>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录；</li> <li>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管；</li></ul></li> <li>如果我们以SSH的方式访问Git仓库，那么就需要生产对应的公钥和私钥：<a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Generating-Your-SSH-Public-Key" target="_blank" rel="noopener noreferrer">生成你的 SSH 公钥相关文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>ssh-keygen -o //生成公共/私有 rsa 密钥对。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/15b6877f9a9c9f3029.png" alt="15b6877f9a9c9f3029.png"></p> <h3 id="_6-5-管理远程服务器"><a href="#_6-5-管理远程服务器" class="header-anchor">#</a> 6.5.管理远程服务器</h3> <ul><li>查看远程地址：比如我们之前从GitHub上clone下来的代码，它就是有自己的远程仓库的：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> remote
<span class="token function">git</span> remote –v  //-v是—verbose的缩写<span class="token punctuation">(</span>冗长的<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/19.png" alt="19.png"></p> <ul><li>添加远程地址：我们也可以继续添加远程服务器（让本地的仓库和远程服务器仓库建立连接）：
<ul><li><code>&lt;shortname&gt;</code>   ： 远程仓库地址简称  -&gt; 一般设置为origin</li> <li><code>&lt;url&gt;</code>  ：远程仓库地址</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//git remote <span class="token function">add</span> <span class="token operator">&lt;</span>shortname<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>
<span class="token function">git</span> remote <span class="token function">add</span> github https://github.com/lyk19990226/wyymusic.git
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>重命名远程地址：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> remote <span class="token function">rename</span> github origin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>移除远程地址：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> remote remove origin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/20.png" alt="20.png"></p> <h3 id="_6-6-远程仓库的交互"><a href="#_6-6-远程仓库的交互" class="header-anchor">#</a> 6.6.远程仓库的交互</h3> <ul><li>从远程仓库clone代码：将存储库克隆到新创建的目录中；</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/lyk19990226/wyymusic.git
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>将代码push到远程仓库：将本地仓库的代码推送到远程仓库中；
<ul><li>默认情况下是将当前分支（比如master）push到origin远程仓库的；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> push

//git push -u <span class="token operator">&lt;</span>shortname<span class="token operator">&gt;</span> master
<span class="token function">git</span> push -u origin master
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>从远程仓库fetch代码：从远程仓库获取最新的代码</p> <ul><li>默认情况下是从origin中获取代码；</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> fetch
<span class="token function">git</span> fetch origin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并；</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> merge
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作\</p></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> pull
//或者
<span class="token function">git</span> fetch 
<span class="token function">git</span> merge //也可 <span class="token function">git</span> rebase   --<span class="token operator">&gt;</span>  具体什么区别，后续学习
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_6-7-常见的开源协议"><a href="#_6-7-常见的开源协议" class="header-anchor">#</a> 6.7.常见的开源协议</h3> <p><img src="https://s1.imagehub.cc/images/2022/08/21/163df3c05f0b25d32f.png" alt="163df3c05f0b25d32f.png"></p> <h2 id="_7、git的标签tag用法"><a href="#_7、git的标签tag用法" class="header-anchor">#</a> 7、Git的标签tag用法</h2> <h3 id="_7-1-git标签-tag-创建tag"><a href="#_7-1-git标签-tag-创建tag" class="header-anchor">#</a> 7.1.Git标签（tag） - 创建tag</h3> <ul><li>对于重大的版本我们常常会打上一个标签，以表示它的重要性：
<ul><li>Git 可以给仓库历史中的某一个提交打上标签；</li> <li>比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）；</li></ul></li> <li>创建标签：
<ul><li>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）；</li> <li>附注标签：通过-a选项，并且通过-m添加额外信息；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> tag v1.0.0
<span class="token function">git</span> tag -a v1.0.1 -m <span class="token string">'标签额外信息补充'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。
<ul><li>在创建完标签后你必须显式地推送标签到共享服务器上，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签；</li></ul></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>git push origin v1.0.0 //指定本地仓库创建的具体标签 共享到git远程仓库上
git push origin --tags //将本地仓库创建的所有标签 共享到git远程仓库上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_7-2-git标签-tag-删除和检出tag"><a href="#_7-2-git标签-tag-删除和检出tag" class="header-anchor">#</a> 7.2.Git标签（tag） - 删除和检出tag</h3> <ul><li>删除本地tag：
<ul><li>要删除掉你本地仓库上的标签，可以使用命令 git tag -d</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> tag -d v1.0.1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>删除远程tag：
<ul><li>要删除远程的tag我们可以通过git push  –delete</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> push origin --delete v1.0.1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>检出tag：
<ul><li>如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令；</li> <li>通常我们在检出tag的时候还会创建一个对应的分支（分支后续了解）；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout v1.0.0 // 检出某个标签所指向的文件版本
<span class="token function">git</span> reset --hard v1.0.0 //回退到某个标签所指向的文件版本
//上面两命令区别如下图参考
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/21.png" alt="21.png"></p> <p><img src="https://s1.imagehub.cc/images/2022/08/21/22.png" alt="22.png"></p> <h2 id="_8、git分支的使用过程"><a href="#_8、git分支的使用过程" class="header-anchor">#</a> 8、Git分支的使用过程</h2> <h3 id="_8-1-git提交对象-commit-object"><a href="#_8-1-git提交对象-commit-object" class="header-anchor">#</a> 8.1.Git提交对象（Commit Object）</h3> <ul><li>几乎所有的版本控制系统都以某种形式支持分支。
<ul><li>使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</li></ul></li> <li>在进行提交操作时，Git 会保存一个提交对象（commit object）：
<ul><li>该提交对象会包含一个指向暂存内容快照的指针；</li> <li>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针；
<ul><li>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象；</li> <li>而由多个分支合并产生的提交对象有多个父对象；</li></ul></li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/23.png" alt="23.png"></p> <h3 id="_8-2-git-master分支"><a href="#_8-2-git-master分支" class="header-anchor">#</a> 8.2.Git master分支</h3> <ul><li>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。
<ul><li>Git 的默认分支名字是 master，在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支；</li> <li>master 分支会在每次提交时自动移动；</li></ul></li> <li>Git 的 master 分支并不是一个特殊分支。
<ul><li>它就跟其它分支完全没有区别；</li> <li>之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/24.png" alt="24.png"></p> <h3 id="_8-3-git创建分支"><a href="#_8-3-git创建分支" class="header-anchor">#</a> 8.3.Git创建分支</h3> <ul><li>Git 是怎么创建新分支的呢？
<ul><li>很简单，它只是为你创建了一个可以移动的新的指针；</li></ul></li> <li>比如，创建一个 testing 分支， 你需要使用 git branch 命令：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> branch testing
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/25.png" alt="25.png"></p> <ul><li>那么，Git 又是怎么知道当前在哪一个分支上呢？
<ul><li>也很简单，它有一个名为 HEAD 的特殊指针；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//当然我们也可以通过如下命令来切换HEAD指针
<span class="token function">git</span> checkout testing
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/26.png" alt="26.png"></p> <h3 id="_8-4-git分支提交"><a href="#_8-4-git分支提交" class="header-anchor">#</a> 8.4.Git分支提交</h3> <ul><li>如果我们指向某一个分支，并且在这个分支上提交(commit)：</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/27.png" alt="27.png"></p> <ul><li>你也可以切换回到master分支，继续开发：</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/28.png" alt="28.png"></p> <h3 id="_8-5-创建分支同时切换"><a href="#_8-5-创建分支同时切换" class="header-anchor">#</a> 8.5.创建分支同时切换</h3> <ul><li>创建新分支的同时切换过去
<ul><li>通常我们会在创建一个新分支后立即切换过去；</li> <li>这可以用 <code>git checkout -b &lt;newbranchname&gt;</code>  一条命令搞定；</li></ul></li></ul> <h3 id="_8-6-为什么需要使用分支呢"><a href="#_8-6-为什么需要使用分支呢" class="header-anchor">#</a> 8.6.为什么需要使用分支呢？</h3> <ul><li>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。
<ul><li>开发某个项目，在默认分支master上进行开发；</li> <li>实现项目的功能需求，不断提交；</li> <li>并且在一个大的版本完成时，发布版本，打上一个tag v1.0.0；</li></ul></li> <li>继续开发后续的新功能，正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补， 你将按照如下方式来处理：
<ul><li>切换到tag v1.0.0的版本，并且创建一个分支hotfix；</li></ul></li> <li>想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout -b hotfix
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/29.png" alt="29.png"></p> <h3 id="_8-7-分支开发和合并"><a href="#_8-7-分支开发和合并" class="header-anchor">#</a> 8.7.分支开发和合并</h3> <ul><li>分支上开发、修复bug：
<ul><li>我们可以在创建的hotfix分支上继续开发工作或者修复bug；</li> <li>当完成要做的工作后，重新打上一个新的tag v1.0.1；</li></ul></li> <li>切换回master分支，但是这个时候master分支也需要修复刚刚的bug：
<ul><li>所以我们需要将master分支和hotfix分支进行合并；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout master  //切换回 master分支
<span class="token function">git</span> merge hotfix  //在master分支上执行该命令：   即在master分支上创建一个新的提交文件版本信息 并 将hotfix分支 合并到master分支的（新的提交文件版本信息）上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/30.png" alt="30.png"></p> <h3 id="_8-8-查看和删除分支"><a href="#_8-8-查看和删除分支" class="header-anchor">#</a> 8.8.查看和删除分支</h3> <ul><li>如果我们希望查看当前所有的分支，可以通过以下命令：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token comment"># 查看当前所有的分支</span>
<span class="token function">git</span> branch –v <span class="token comment"># 同时查看最后一次提交</span>
<span class="token function">git</span> branch --merged <span class="token comment"># 查看所有合并到当前分支的分支</span>
<span class="token function">git</span> branch --no-merged <span class="token comment"># 查看所有没有合并到当前分支的分支</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>如果某些已经合并的分支我们不再需要了，那么可以将其移除掉：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> branch –d hotfix <span class="token comment"># 删除当前分支</span>
<span class="token function">git</span> branch –D hotfix <span class="token comment"># 强制删除某一个分支</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_9、工作中的git-flow"><a href="#_9、工作中的git-flow" class="header-anchor">#</a> 9、工作中的Git Flow</h2> <h3 id="_9-1-git的工作流-git-flow"><a href="#_9-1-git的工作流-git-flow" class="header-anchor">#</a> 9.1.Git的工作流（git flow）</h3> <ul><li>由于Git上分支的使用的便捷性，产生了很多Git的工作流：
<ul><li>也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；</li> <li>你可以定期地把某些主题分支合并入其他分支中；</li></ul></li> <li>比如以下的工作流：
<ul><li>master作为主分支；</li> <li>develop作为开发分支，并且有稳定版本时，合并到master分支中；</li> <li>topic作为某一个主题或者功能或者特性的分支进行开发，开发完成后合并到develop分支中；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/31.png" alt="31.png"></p> <h3 id="_9-2-比较常见的git-flow"><a href="#_9-2-比较常见的git-flow" class="header-anchor">#</a> 9.2.比较常见的git flow</h3> <p><img src="https://s1.imagehub.cc/images/2022/08/21/32.png" alt="32.png"></p> <h2 id="_10、git远程分支的管理"><a href="#_10、git远程分支的管理" class="header-anchor">#</a> 10、Git远程分支的管理</h2> <h3 id="_10-1-git的远程分支"><a href="#_10-1-git的远程分支" class="header-anchor">#</a> 10.1.Git的远程分支</h3> <ul><li>远程分支是也是一种分支结构：
<ul><li>以<code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名的；如：origin/main</li></ul></li> <li>如果我们刚刚clone下来代码，分支的结构如下：</li> <li>如果其他人修改了代码，那么远程分支结构如下：
<ul><li>你需要通过fetch来获取最新的远程分支提交信息；</li></ul></li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/33.png" alt="33.png"></p> <h3 id="_10-2-远程分支的管理"><a href="#_10-2-远程分支的管理" class="header-anchor">#</a> 10.2.远程分支的管理</h3> <ul><li>操作一：推送分支到远程
<ul><li>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上；</li> <li>运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code> ；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> push origin <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>操作二：跟踪远程分支
<ul><li>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支；</li> <li>如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout --track /</li> <li>如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout --track <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>
<span class="token function">git</span> checkout <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>操作三：删除远程分支
<ul><li>如果某一个远程分支不再使用，我们想要删除掉，可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> push origin --delete <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_11、git-rebase的使用"><a href="#_11、git-rebase的使用" class="header-anchor">#</a> 11、Git rebase的使用</h2> <h3 id="_11-1-git-rebase用法"><a href="#_11-1-git-rebase用法" class="header-anchor">#</a> 11.1.Git rebase用法</h3> <ul><li>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。(居然区别，如下图进行理解)</li></ul> <p><img src="https://s1.imagehub.cc/images/2022/08/21/dsfsd.png" alt="dsfsd.png"></p> <p><img src="https://s1.imagehub.cc/images/2022/08/21/35.png" alt="35.png"></p> <ul><li>什么是rebase呢？
<ul><li>在上面的图例中，你可以提取在 C4~C5 中引入的补丁和修改，然后在 C8 的基础上应用一次；</li> <li>在 Git 中，这种操作就叫做 变基（rebase）；</li> <li>你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样；</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> rebase main  //main 目标基底
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>注意：千万不要在主分支使用git rebase</li></ul> <h3 id="_11-2-rebase的原理"><a href="#_11-2-rebase的原理" class="header-anchor">#</a> 11.2.rebase的原理</h3> <ul><li>rebase是如何工作的呢？
<ul><li>它的原理是首先找到这两个分支（即当前分支 dev、变基操作的目标基底分支 main） 的最近共同祖先 C3；</li> <li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件；</li> <li>然后将当前分支指向目标基底 C8；</li> <li>最后以此将之前另存为临时文件的修改依序应用；</li></ul></li> <li>我们可以再次执行main上的合并操作：</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout main
<span class="token function">git</span> merge dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://s1.imagehub.cc/images/2022/08/21/36.png" alt="36.png"></p> <h2 id="_12、git常见命令速查表"><a href="#_12、git常见命令速查表" class="header-anchor">#</a> 12、Git常见命令速查表</h2> <p><img src="https://s1.imagehub.cc/images/2022/08/21/37.png" alt="37.png"></p> <h2 id="_13、git常见命令总结"><a href="#_13、git常见命令总结" class="header-anchor">#</a> 13、git常见命令总结</h2> <ol><li><p><code>git config --global user.name &quot;coderhub&quot;</code>   /    <code>git confit --global user.email &quot;coderhub@qq.com&quot;</code>  配置个人信息</p></li> <li><p><code>git config --list</code>  查看配置信息列表</p></li> <li><p><code>git config --global alias.st status</code>  取别名（了解）-&gt; 该命令执行后：<code>git st</code> 相当于 <code>git status</code></p></li> <li><p><code>git init</code>  初始化Git仓库</p></li> <li><p><code>git clone git仓库网址</code>  克隆git服务器上的项目</p></li> <li><p><code>git status</code>  /  <code>git status -short -&gt; 简写：git status -s</code>  检测文件的状态</p></li> <li><p><code>git add .</code>  将该目录下所有文件添加到暂存区 （对文件进行跟踪）</p></li> <li><p><code>git commit -m '提交信息'</code>   文件更新提交 ，将暂存区的文件加入到git本地仓库中</p></li> <li><p><code>git commit -a -m '修改了xxx文件'</code>  如果你觉得<strong>修改文件的add操作</strong>,加上commit的操作有点繁琐，那么可以将两个命令结合来使用（注意刚添加的新文件不可使用该命令结合；必须先执行 add 再 commit）</p></li> <li><p><code>git log</code>  查看提交的历史   /   <code>git log --pretty=oneline</code> 漂亮单线历史提交记录  /   <code>git log --pretty=oneline --graph</code> 漂亮的图形单线历史提交记录</p> <ul><li><code>git reflog</code>    如果我们回退到了之前版本，但是想看全部提交历史版本信息;可用git reflog 查看</li></ul></li> <li><p><code>git reset --hrad 具体版本校验和</code>  回退到具体版本（如：git reset --hard 2d44982）</p></li> <li><p><code>git remote</code>  查看远程地址；如果想看具体远程地址 -&gt;  <code>git remote –v</code></p></li> <li><p><code>git remote add origin https://github.com/lyk19990226/wyymusic.git</code>  添加(连接) 远程地址</p></li> <li><p><code>git push</code>   /   <code>git push -u origin 分支名</code>   将当前分支推送到(origin)远程仓库的指定分支</p></li> <li><p><code>git pull</code>  从远程仓库获取最新的代码并合并到本地仓库;<code>(git pull 相当于 git fetch + git merge)</code>如下：</p> <ul><li><code>git fetch</code>  默认情况下是从origin中获取代码  <code>git origin</code></li> <li><code>git merge (rebase)</code> 获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并</li></ul></li> <li><p><code>git tag</code>  查看本地仓库创建的所有标签</p> <ul><li><code>git tag v1.0.0</code>   在本次提交信息中创建标签  （本地仓库）</li> <li><code>git tag -a v1.0.1 -m '标签额外信息补充'</code>   在本次提交信息中创建标签 并 加上额外的信息补充 （本地仓库）</li> <li>注意：默认情况下，git push 命令并不会传送（本地仓库创建的）标签到远程仓库服务器上。
<ul><li>在创建完标签后你必须显式地推送标签到共享服务器上，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签；具体操作如下：</li></ul></li> <li><code>git push origin v1.0.0</code>   指定本地仓库创建的具体标签 共享到git远程仓库上</li> <li><code>git push origin --tags</code>   将本地仓库创建的所有标签 共享到git远程仓库上、</li> <li><code>git tag -d v1.0.1</code>    删除本地仓库的标签 tag</li> <li><code>git push origin --delete v1.0.1</code>   删除远程仓库的标签 tag</li> <li><code>git checkout v1.0.0</code>     检出某个标签所指向的文件版本   -&gt; 检出tag</li> <li><code>git reset --hard v1.0.0</code>   回退到某个标签所指向的文件版本</li></ul></li> <li><p><code>git branch</code>  查看本地所有分支</p> <ul><li><p><code>git branch 分支名</code>  创建一个分支</p></li> <li><p><code>git checkout 分支名</code>  切换到指定分支</p> <ul><li><code>git switch 分支名</code>   切换到指定分支</li></ul></li> <li><p><code>git checkout -b 分支名</code>  创建一个分支，并切换到该分支(指新创建的分支)</p></li> <li><p><code>git merge 需合并到该分支的分支名</code>    合并分支  （跟rebase的具体区别可查看：11.1图例）</p></li> <li><p><code>git rebase 需合并到该分支的分支名</code>  合并分支  （跟merge的具体区别可查看：11.1图例）</p></li> <li><p><code>git branch –v</code>   查看当前所有的分支，同时查看最后一次提交</p></li> <li><p><code>git branch --merged</code>    查看所有合并到当前分支的分支</p></li> <li><p><code>git branch --no-merged</code>   查看所有没有合并到当前分支的分支</p></li> <li><p><code>git branch –d 分支名</code>   删除当前指定分支</p></li> <li><p><code>git branch –D 分支名</code>  强制删除指定分支</p></li> <li><p><code>git push origin --delete 分支名</code>  删除远程仓库指定分支</p></li> <li><p><code>git checkout --track origin/分支名</code>  跟踪远程仓库指定分支</p></li></ul></li></ol> <h2 id="_14、公司业务具体开发操作"><a href="#_14、公司业务具体开发操作" class="header-anchor">#</a> 14、公司业务具体开发操作</h2> <h3 id="_14-1-已经有远程仓库"><a href="#_14-1-已经有远程仓库" class="header-anchor">#</a> 14.1.已经有远程仓库</h3> <h4 id="已经有项目了-并且有远程仓库"><a href="#已经有项目了-并且有远程仓库" class="header-anchor">#</a> 已经有项目了，并且有远程仓库</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone xxxxxxxx.com
//进行开发
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">'提交'</span>
<span class="token function">git</span> pull // <span class="token function">git</span> fetch + <span class="token function">git</span> merger
<span class="token function">git</span> push
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_14-2-没有远程仓库"><a href="#_14-2-没有远程仓库" class="header-anchor">#</a> 14.2.没有远程仓库</h3> <h4 id="开发一个全新的项目-由你来搭建"><a href="#开发一个全新的项目-由你来搭建" class="header-anchor">#</a> 开发一个全新的项目(由你来搭建)</h4> <ul><li>方案一：先创建一个远程仓库, 再clone下来，再进行项目搭建（推荐）</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone xxxxxxxx.com
//在clone下来的文件夹中开始搭建整个项目
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">'提交'</span>
<span class="token function">git</span> push
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>方案二：2.1:先在本地搭建项目,然后创建远程仓库,  然后本地仓库添加(连接)远程仓库 （稍微麻烦）
<ul><li>远程仓库分支名(master)跟本地仓库分支名(master)；<strong>即分支名一样的情况：</strong></li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//本地搭建好项目后  -<span class="token operator">&gt;</span>  创建远程仓库
<span class="token function">git</span> remote <span class="token function">add</span> origin xxxxxx.com
<span class="token function">git</span> fetch
<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/main 
<span class="token function">git</span> merge  --allow-unrelated-histories  // 如果合并发现又打开一个另外一个git bash窗口，叫你输入合并理由的；你可以直接输入 -<span class="token operator">&gt;</span>   :wq + 回车键ebter    强制退出
<span class="token function">git</span> push
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>方案二：2.2:先在本地搭建项目,然后创建远程仓库,  然后本地仓库添加(连接)远程仓库（稍微麻烦）
<ul><li>远程仓库分支名(main) 和 本地仓库分支名(master) ；<strong>即分支名不一样的情况：</strong></li> <li>git checkout --track origin/分支名</li></ul></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//远程分支名为main<span class="token punctuation">;</span>  本地分支名为master 的情况  
<span class="token function">git</span> remote origin <span class="token function">add</span> git@152.136.185.210:coderhub/coder_demo.git
<span class="token function">git</span> fetch
<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/main 【将上游分支设置为：origin/main即main<span class="token punctuation">;</span><span class="token punctuation">(</span>origin/main是从git服务器远程仓库 fetch下来的远程分支<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">git</span> merge  --allow-unrelated-histories  （强制合并两个没有任何关系的分支；即没有共同的祖先对象）

<span class="token function">git</span> config push.default upstream
//（默认情况下配置为：config push.defult simple；而simple：默认远程推送同名的当前分支即master。但是远程分支为main；所以会报错）
//我们需要设置成upstream（即使用上游分支）：远程推送 本地的上游分支-<span class="token operator">&gt;</span>上游分支我们在前面已经设置成
origin/main<span class="token punctuation">(</span>即main<span class="token punctuation">;</span>则远程分支跟本地分支同名<span class="token punctuation">)</span>即可推送成功；

<span class="token function">git</span> push //推送成功
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间: </span> <span class="time">2022/08/21, 17:31:13</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blogs/frontEnd/Engineering/220818-01.html" class="prev">
            五、webpack常见的插件和模式 及 webpack搭建本地服务器
          </a></span> <span class="next"><a href="/blogs/frontEnd/Vue3/220820-01.html">
            一、初识Vuejs开发，vue开发的初体验
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_1、版本控制工具的了解" class="sidebar-link reco-side-_1、版本控制工具的了解" data-v-70334359>1、版本控制工具的了解</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_1-1-认识版本控制-版本控制" class="sidebar-link reco-side-_1-1-认识版本控制-版本控制" data-v-70334359>1.1.认识版本控制（版本控制）</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_1-2-版本控制的功能" class="sidebar-link reco-side-_1-2-版本控制的功能" data-v-70334359>1.2.版本控制的功能</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_1-3-版本控制的历史" class="sidebar-link reco-side-_1-3-版本控制的历史" data-v-70334359>1.3.版本控制的历史</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_2、集中式和分布式区别" class="sidebar-link reco-side-_2、集中式和分布式区别" data-v-70334359>2、集中式和分布式区别</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_2-1-集中式版本控制" class="sidebar-link reco-side-_2-1-集中式版本控制" data-v-70334359>2.1.集中式版本控制</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_2-2-分布式版本控制" class="sidebar-link reco-side-_2-2-分布式版本控制" data-v-70334359>2.2.分布式版本控制</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3、git的环境安装搭建" class="sidebar-link reco-side-_3、git的环境安装搭建" data-v-70334359>3、Git的环境安装搭建</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3-1-git的安装" class="sidebar-link reco-side-_3-1-git的安装" data-v-70334359>3.1.Git的安装</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3-2-bash-cmd-gui-区别" class="sidebar-link reco-side-_3-2-bash-cmd-gui-区别" data-v-70334359>3.2.Bash – CMD – GUI 区别</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3-3-git的配置分类" class="sidebar-link reco-side-_3-3-git的配置分类" data-v-70334359>3.3.Git的配置分类</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3-4-git的配置选项" class="sidebar-link reco-side-_3-4-git的配置选项" data-v-70334359>3.4.Git的配置选项</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_3-5-git的别名-alias" class="sidebar-link reco-side-_3-5-git的别名-alias" data-v-70334359>3.5.Git的别名（alias）</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_4、git初始化本地仓库" class="sidebar-link reco-side-_4、git初始化本地仓库" data-v-70334359>4、Git初始化本地仓库</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_4-1-获取git仓库-git-init-git-clone" class="sidebar-link reco-side-_4-1-获取git仓库-git-init-git-clone" data-v-70334359>4.1.获取Git仓库 – git init/git clone</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5、git记录更新变化过程" class="sidebar-link reco-side-_5、git记录更新变化过程" data-v-70334359>5、Git记录更新变化过程</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-1-文件的状态划分" class="sidebar-link reco-side-_5-1-文件的状态划分" data-v-70334359>5.1.文件的状态划分</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-2-git操作流程图" class="sidebar-link reco-side-_5-2-git操作流程图" data-v-70334359>5.2.Git操作流程图</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-3-检测文件的状态-git-status" class="sidebar-link reco-side-_5-3-检测文件的状态-git-status" data-v-70334359>5.3.检测文件的状态 - git status</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-4-文件添加到暂存区-git-add" class="sidebar-link reco-side-_5-4-文件添加到暂存区-git-add" data-v-70334359>5.4.文件添加到暂存区 – git add</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-5-git忽略文件-gitignore文件" class="sidebar-link reco-side-_5-5-git忽略文件-gitignore文件" data-v-70334359>5.5.git忽略文件（.gitignore文件）</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-6-文件更新提交-git-commit-m" class="sidebar-link reco-side-_5-6-文件更新提交-git-commit-m" data-v-70334359>5.6.文件更新提交 – git commit -m</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-7-git的校验和" class="sidebar-link reco-side-_5-7-git的校验和" data-v-70334359>5.7.Git的校验和</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-8-查看提交的历史-git-log" class="sidebar-link reco-side-_5-8-查看提交的历史-git-log" data-v-70334359>5.8.查看提交的历史 – git log</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_5-9-版本回退-git-reset" class="sidebar-link reco-side-_5-9-版本回退-git-reset" data-v-70334359>5.9.版本回退 – git reset</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6、git远程仓库和验证" class="sidebar-link reco-side-_6、git远程仓库和验证" data-v-70334359>6、Git远程仓库和验证</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-1-什么是远程仓库" class="sidebar-link reco-side-_6-1-什么是远程仓库" data-v-70334359>6.1.什么是远程仓库？</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-2-远程仓库的验证" class="sidebar-link reco-side-_6-2-远程仓库的验证" data-v-70334359>6.2.远程仓库的验证</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-3-远程仓库的验证-凭证" class="sidebar-link reco-side-_6-3-远程仓库的验证-凭证" data-v-70334359>6.3.远程仓库的验证 – 凭证</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-4-远程仓库的验证-ssh密钥" class="sidebar-link reco-side-_6-4-远程仓库的验证-ssh密钥" data-v-70334359>6.4.远程仓库的验证 – SSH密钥</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-5-管理远程服务器" class="sidebar-link reco-side-_6-5-管理远程服务器" data-v-70334359>6.5.管理远程服务器</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-6-远程仓库的交互" class="sidebar-link reco-side-_6-6-远程仓库的交互" data-v-70334359>6.6.远程仓库的交互</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_6-7-常见的开源协议" class="sidebar-link reco-side-_6-7-常见的开源协议" data-v-70334359>6.7.常见的开源协议</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_7、git的标签tag用法" class="sidebar-link reco-side-_7、git的标签tag用法" data-v-70334359>7、Git的标签tag用法</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_7-1-git标签-tag-创建tag" class="sidebar-link reco-side-_7-1-git标签-tag-创建tag" data-v-70334359>7.1.Git标签（tag） - 创建tag</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_7-2-git标签-tag-删除和检出tag" class="sidebar-link reco-side-_7-2-git标签-tag-删除和检出tag" data-v-70334359>7.2.Git标签（tag） - 删除和检出tag</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8、git分支的使用过程" class="sidebar-link reco-side-_8、git分支的使用过程" data-v-70334359>8、Git分支的使用过程</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-1-git提交对象-commit-object" class="sidebar-link reco-side-_8-1-git提交对象-commit-object" data-v-70334359>8.1.Git提交对象（Commit Object）</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-2-git-master分支" class="sidebar-link reco-side-_8-2-git-master分支" data-v-70334359>8.2.Git master分支</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-3-git创建分支" class="sidebar-link reco-side-_8-3-git创建分支" data-v-70334359>8.3.Git创建分支</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-4-git分支提交" class="sidebar-link reco-side-_8-4-git分支提交" data-v-70334359>8.4.Git分支提交</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-5-创建分支同时切换" class="sidebar-link reco-side-_8-5-创建分支同时切换" data-v-70334359>8.5.创建分支同时切换</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-6-为什么需要使用分支呢" class="sidebar-link reco-side-_8-6-为什么需要使用分支呢" data-v-70334359>8.6.为什么需要使用分支呢？</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-7-分支开发和合并" class="sidebar-link reco-side-_8-7-分支开发和合并" data-v-70334359>8.7.分支开发和合并</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_8-8-查看和删除分支" class="sidebar-link reco-side-_8-8-查看和删除分支" data-v-70334359>8.8.查看和删除分支</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_9、工作中的git-flow" class="sidebar-link reco-side-_9、工作中的git-flow" data-v-70334359>9、工作中的Git Flow</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_9-1-git的工作流-git-flow" class="sidebar-link reco-side-_9-1-git的工作流-git-flow" data-v-70334359>9.1.Git的工作流（git flow）</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_9-2-比较常见的git-flow" class="sidebar-link reco-side-_9-2-比较常见的git-flow" data-v-70334359>9.2.比较常见的git flow</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_10、git远程分支的管理" class="sidebar-link reco-side-_10、git远程分支的管理" data-v-70334359>10、Git远程分支的管理</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_10-1-git的远程分支" class="sidebar-link reco-side-_10-1-git的远程分支" data-v-70334359>10.1.Git的远程分支</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_10-2-远程分支的管理" class="sidebar-link reco-side-_10-2-远程分支的管理" data-v-70334359>10.2.远程分支的管理</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_11、git-rebase的使用" class="sidebar-link reco-side-_11、git-rebase的使用" data-v-70334359>11、Git rebase的使用</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_11-1-git-rebase用法" class="sidebar-link reco-side-_11-1-git-rebase用法" data-v-70334359>11.1.Git rebase用法</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_11-2-rebase的原理" class="sidebar-link reco-side-_11-2-rebase的原理" data-v-70334359>11.2.rebase的原理</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_12、git常见命令速查表" class="sidebar-link reco-side-_12、git常见命令速查表" data-v-70334359>12、Git常见命令速查表</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_13、git常见命令总结" class="sidebar-link reco-side-_13、git常见命令总结" data-v-70334359>13、git常见命令总结</a></li><li class="level-2" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_14、公司业务具体开发操作" class="sidebar-link reco-side-_14、公司业务具体开发操作" data-v-70334359>14、公司业务具体开发操作</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_14-1-已经有远程仓库" class="sidebar-link reco-side-_14-1-已经有远程仓库" data-v-70334359>14.1.已经有远程仓库</a></li><li class="level-3" data-v-70334359><a href="/blogs/frontEnd/Engineering/220819-01.html#_14-2-没有远程仓库" class="sidebar-link reco-side-_14-2-没有远程仓库" data-v-70334359>14.2.没有远程仓库</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/bgm-player/彩虹.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/bgm-player/彩虹.png" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;border-radius:20px;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/bgm-player/彩虹.png);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>彩虹</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>周杰伦</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><div><div class="sponsor-container" data-v-30e8c72d><div class="sponsor-love position-absolute transition-3ms" data-v-30e8c72d>
    打赏在这哟
  </div> <a href="https://github.com/lyk19990226" target="_blank" title="Github" class="sponsor-github position-absolute transition-3ms" data-v-30e8c72d></a> <ul class="sponsor-payment-options transition-3ms" data-v-30e8c72d><li id="alipay-option" class="transition-3ms" data-v-30e8c72d></li> <li id="wechat-option" class="transition-3ms" data-v-30e8c72d></li></ul> <div class="sponsor-qrcode-container position-absolute" style="display:none;" data-v-30e8c72d data-v-30e8c72d><div class="sponsor-qrcode-info" style="background-image:url();pointer-events:none;display:none;" data-v-30e8c72d data-v-30e8c72d></div></div> <div class="sponsor-message position-absolute" style="display:none;" data-v-30e8c72d data-v-30e8c72d>
      主人忘记设置啦
    </div></div></div><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div><div></div></div></div>
    <script src="/assets/js/app.d92951ef.js" defer></script><script src="/assets/js/3.ad8ffd82.js" defer></script><script src="/assets/js/1.7d84b754.js" defer></script><script src="/assets/js/29.d124476c.js" defer></script>
  </body>
</html>
