(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{657:function(t,_,a){"use strict";a.r(_);var v=a(5),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1、认识生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、认识生命周期"}},[t._v("#")]),t._v(" 1、认识生命周期")]),t._v(" "),a("ul",[a("li",[t._v("什么是生命周期呢？\n"),a("ul",[a("li",[t._v("生物学上，生物生命周期指得是一个生物体在生命开始到结束周而复始所历经的一系列变化过程；")]),t._v(" "),a("li",[t._v("每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程；")]),t._v(" "),a("li",[t._v("在这个过程中的某一个阶段，我们可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）；")]),t._v(" "),a("li",[t._v("但是我们如何可以知道目前组件正在哪一个过程呢？Vue给我们提供了组件的生命周期函数；")])])]),t._v(" "),a("li",[t._v("生命周期函数：\n"),a("ul",[a("li",[t._v("生命周期函数是一些钩子函数（回调函数），在某个时间会被Vue源码内部进行回调；")]),t._v(" "),a("li",[t._v("通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段；")]),t._v(" "),a("li",[t._v("那么我们就可以在该生命周期中编写属于自己的逻辑代码了；")])])]),t._v(" "),a("li",[t._v("声明周期函数\n"),a("ol",[a("li",[t._v("beforeCreate")]),t._v(" "),a("li",[t._v("create")]),t._v(" "),a("li",[t._v("beforeMount")]),t._v(" "),a("li",[t._v("mounted")]),t._v(" "),a("li",[t._v("beforeUpdate")]),t._v(" "),a("li",[t._v("updated")]),t._v(" "),a("li",[t._v("beforeUnmount")]),t._v(" "),a("li",[t._v("unmounted")])])])]),t._v(" "),a("h2",{attrs:{id:"_2、生命周期的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、生命周期的流程"}},[t._v("#")]),t._v(" 2、生命周期的流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/09/1.png",alt:"1.png"}})]),t._v(" "),a("h2",{attrs:{id:"_3、-refs的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、-refs的使用"}},[t._v("#")]),t._v(" 3、$refs的使用")]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://vuejs.bootcss.com/api/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue的api"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例：")]),t._v(" "),a("ul",[a("li",[t._v("在Vue开发中我们是不推荐进行DOM操作的；")]),t._v(" "),a("li",[t._v("这个时候，我们可以给元素或者组件绑定一个ref的attribute属性；")])])]),t._v(" "),a("li",[a("p",[t._v("组件实例有一个$refs属性：")]),t._v(" "),a("ul",[a("li",[t._v("它一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例。")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/2.png",alt:"2.png"}})]),t._v(" "),a("h2",{attrs:{id:"_4、-parent-和-root"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、-parent-和-root"}},[t._v("#")]),t._v(" 4、"),a("code",[t._v("$parent 和 $root")])]),t._v(" "),a("ul",[a("li",[t._v("我们可以通过"),a("code",[t._v("$parent")]),t._v("来访问父组件。")]),t._v(" "),a("li",[t._v("我们可以通过"),a("code",[t._v("$root")]),t._v("来获取当前组件树的根")]),t._v(" "),a("li",[t._v("注意：在Vue3中已经移除了$children的属性，所以不可以使用了")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/3.png",alt:"3.png"}})]),t._v(" "),a("h2",{attrs:{id:"_5、动态组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、动态组件"}},[t._v("#")]),t._v(" 5、动态组件")]),t._v(" "),a("h3",{attrs:{id:"_5-1-切换组件案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-切换组件案例"}},[t._v("#")]),t._v(" 5.1.切换组件案例")]),t._v(" "),a("ul",[a("li",[t._v("比如我们现在想要实现了一个功能：\n"),a("ul",[a("li",[t._v("点击一个tab-bar，切换不同的组件显示；")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/4.png",alt:"4.png"}})]),t._v(" "),a("ul",[a("li",[t._v("这个案例我们可以通过两种不同的实现思路来实现：\n"),a("ul",[a("li",[t._v("方式一：通过v-if来判断，显示不同的组件；")]),t._v(" "),a("li",[t._v("方式二：动态组件的方式；")])])])]),t._v(" "),a("h3",{attrs:{id:"_5-2-v-if显示不同的组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-v-if显示不同的组件"}},[t._v("#")]),t._v(" 5.2.v-if显示不同的组件")]),t._v(" "),a("ul",[a("li",[t._v("我们可以先通过v-if来判断显示不同的组件，这个可以使用我们之前讲过的知识来实现：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/5.png",alt:"5.png"}})]),t._v(" "),a("h3",{attrs:{id:"_5-3-动态组件的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-动态组件的实现"}},[t._v("#")]),t._v(" 5.3.动态组件的实现")]),t._v(" "),a("ul",[a("li",[t._v("动态组件是使用 component 组件，通过一个特殊的attribute   "),a("code",[t._v("is")]),t._v("  来实现：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/6.png",alt:"6.png"}})]),t._v(" "),a("ul",[a("li",[t._v("这个currentTab的值需要是什么内容呢？\n"),a("ul",[a("li",[t._v("全局注册：可以是通过component函数注册的组件；")]),t._v(" "),a("li",[t._v("布局注册：在一个组件对象的components对象中注册的组件；")])])])]),t._v(" "),a("h3",{attrs:{id:"_5-4-动态组件的传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-动态组件的传值"}},[t._v("#")]),t._v(" 5.4.动态组件的传值")]),t._v(" "),a("ul",[a("li",[t._v("如果是动态组件我们可以给它们传值和监听事件吗？\n"),a("ul",[a("li",[t._v("也是一样的；")]),t._v(" "),a("li",[t._v("只是我们需要将属性和监听事件放到component上来使用")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://www.imagehub.cc/content/images/users/Gjahr/bkg_1662764022.png",alt:"7.png"}})]),t._v(" "),a("h2",{attrs:{id:"_6、keep-alive属性-缓存组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、keep-alive属性-缓存组件"}},[t._v("#")]),t._v(" 6、keep-alive属性（缓存组件）")]),t._v(" "),a("h3",{attrs:{id:"_6-1-认识keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-认识keep-alive"}},[t._v("#")]),t._v(" 6.1.认识keep-alive")]),t._v(" "),a("ul",[a("li",[t._v("我们先对之前的案例中About组件进行改造：\n"),a("ul",[a("li",[t._v("在其中增加了一个按钮，点击可以递增的功能；")])])]),t._v(" "),a("li",[t._v("比如我们将counter点到16，那么在切换到home再切换回来about时，状态是否可以保持呢？\n"),a("ul",[a("li",[t._v("答案是否定的；")]),t._v(" "),a("li",[t._v("这是因为默认情况下，我们在切换组件后，about组件会被销毁掉，再次回来时会重新创建组件；")])])]),t._v(" "),a("li",[t._v("但是，在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件：keep-alive。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/1092d74a0936d287aa19b705f68fdc34.png",alt:"1092d74a0936d287aa19b705f68fdc34.png"}})]),t._v(" "),a("h3",{attrs:{id:"_6-2-keep-alive属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-keep-alive属性"}},[t._v("#")]),t._v(" 6.2.keep-alive属性")]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://vuejs.bootcss.com/api/#keep-alive",target:"_blank",rel:"noopener noreferrer"}},[t._v("keep-alive属性"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("keep-alive有一些属性：")]),t._v(" "),a("ul",[a("li",[t._v("include - string | RegExp | Array。只有名称匹配的组件会被缓存；")]),t._v(" "),a("li",[t._v("exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存；")]),t._v(" "),a("li",[t._v("max - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；")])])]),t._v(" "),a("li",[a("p",[t._v("include 和 exclude prop 允许组件有条件地缓存：")]),t._v(" "),a("ul",[a("li",[t._v("二者都可以用逗号分隔字符串、正则表达式或一个数组来表示；")]),t._v(" "),a("li",[t._v("匹配首先检查组件自身的 name 选项；如果 "),a("code",[t._v("name")]),t._v(" 选项不可用，则匹配它的局部注册名称 (父组件 "),a("code",[t._v("components")]),t._v(" 选项的键值)。匿名组件不能被匹配。")]),t._v(" "),a("li",[t._v("TIP:在 3.2.34 或以上的版本中，使用 "),a("code",[t._v("<script setup>")]),t._v(" 的单文件组件会自动根据文件名生成对应的 "),a("code",[t._v("name")]),t._v(" 选项，无需再手动声明。")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/99a673f27414ef224.png",alt:"99a673f27414ef224.png"}})]),t._v(" "),a("h2",{attrs:{id:"_7、缓存组件的生命周期activated-和-deactivated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、缓存组件的生命周期activated-和-deactivated"}},[t._v("#")]),t._v(" 7、缓存组件的生命周期activated 和 deactivated")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("对于缓存的组件来说")]),t._v("，再次进入时，我们是"),a("strong",[t._v("不会执行created或者mounted等生命周期函数")]),t._v("的：\n"),a("ul",[a("li",[t._v("但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件；")]),t._v(" "),a("li",[t._v("这个时候我们可以使用"),a("strong",[t._v("activated")]),t._v(" 和 "),a("strong",[t._v("deactivated")]),t._v(" 这两个生命周期钩子函数来监听；")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/10.png",alt:"10.png"}})]),t._v(" "),a("h2",{attrs:{id:"_8、webpack的代码分包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、webpack的代码分包"}},[t._v("#")]),t._v(" 8、Webpack的代码分包")]),t._v(" "),a("ul",[a("li",[t._v("默认的打包过程：\n"),a("ul",[a("li",[t._v("默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组件模块打包到一起（比如一个app.js文件中）；")]),t._v(" "),a("li",[t._v("这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢；")])])]),t._v(" "),a("li",[t._v("打包时，代码的分包：\n"),a("ul",[a("li",[t._v("所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js；")]),t._v(" "),a("li",[t._v("这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容；")])])]),t._v(" "),a("li",[t._v("那么webpack中如何可以对代码进行分包呢？")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/11.png",alt:"11.png"}})]),t._v(" "),a("h2",{attrs:{id:"_9、异步组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、异步组件"}},[t._v("#")]),t._v(" 9、异步组件")]),t._v(" "),a("h3",{attrs:{id:"_9-1-vue中实现异步组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-vue中实现异步组件"}},[t._v("#")]),t._v(" 9.1.Vue中实现异步组件")]),t._v(" "),a("ul",[a("li",[t._v("如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数：defineAsyncComponent。")]),t._v(" "),a("li",[t._v("defineAsyncComponent接受两种类型的参数：\n"),a("ul",[a("li",[t._v("类型一：工厂函数，该工厂函数需要返回一个Promise对象；")]),t._v(" "),a("li",[t._v("类型二：接受一个对象类型，对异步函数进行配置；")])])]),t._v(" "),a("li",[t._v("工厂函数类型一的写法：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/12.png",alt:"12.png"}})]),t._v(" "),a("h3",{attrs:{id:"_9-2-异步组件的写法二-了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-异步组件的写法二-了解"}},[t._v("#")]),t._v(" 9.2.异步组件的写法二（了解）")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/13.png",alt:"13.png"}})]),t._v(" "),a("h2",{attrs:{id:"_10、混入mixin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、混入mixin"}},[t._v("#")]),t._v(" 10、混入Mixin")]),t._v(" "),a("h3",{attrs:{id:"_10-1-认识mixin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-认识mixin"}},[t._v("#")]),t._v(" 10.1.认识Mixin")]),t._v(" "),a("ul",[a("li",[t._v("目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。")]),t._v(" "),a("li",[t._v("在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成：\n"),a("ul",[a("li",[t._v("Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能；")]),t._v(" "),a("li",[t._v("一个Mixin对象可以包含任何组件选项；")]),t._v(" "),a("li",[t._v("当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；")])])])]),t._v(" "),a("h3",{attrs:{id:"_10-2-mixin的基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-mixin的基本使用"}},[t._v("#")]),t._v(" 10.2.Mixin的基本使用")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/14.png",alt:"14.png"}})]),t._v(" "),a("h3",{attrs:{id:"_10-3-mixin的合并规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-mixin的合并规则"}},[t._v("#")]),t._v(" 10.3.Mixin的合并规则")]),t._v(" "),a("ul",[a("li",[t._v("如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？\n"),a("ul",[a("li",[t._v("这里分成不同的情况来进行处理；")])])]),t._v(" "),a("li",[t._v("情况一：如果是data函数的返回值对象\n"),a("ul",[a("li",[t._v("返回值对象默认情况下会进行合并；")]),t._v(" "),a("li",[t._v("如果data返回值对象的属性发生了冲突，那么"),a("strong",[t._v("会保留组件自身的数据")]),t._v("；")])])]),t._v(" "),a("li",[t._v("情况二：如何生命周期钩子函数\n"),a("ul",[a("li",[t._v("生命周期的钩子函数会被合并到数组中，都会被调用；")])])]),t._v(" "),a("li",[t._v("情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。\n"),a("ul",[a("li",[t._v("比如都有methods选项，并且都定义了方法，那么它们都会生效；")]),t._v(" "),a("li",[t._v("但是如果对象的key相同，那么会"),a("strong",[t._v("取组件对象的键值对")]),t._v("；")])])])]),t._v(" "),a("h3",{attrs:{id:"_10-4-全局混入mixin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-全局混入mixin"}},[t._v("#")]),t._v(" 10.4.全局混入Mixin")]),t._v(" "),a("ul",[a("li",[t._v("如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin：\n"),a("ul",[a("li",[t._v("全局的Mixin可以使用 应用app的方法 mixin 来完成注册；")]),t._v(" "),a("li",[t._v("一旦注册，那么全局混入的选项将会影响每一个组件；")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.imagehub.cc/images/2022/09/10/15.png",alt:"15.png"}})])])}),[],!1,null,null,null);_.default=e.exports}}]);